# WCAG Problem Detection & Automated Fixes

Audience: web developers, designers, and accessibility reviewers who maintain this project or integrate the analyzer into their pages.

This document explains how the analyzer detects common WCAG 2.1 (AA) problems and how the code applies CSS fixes automatically where possible.

## Overview

The analyzer is implemented in `script.js` and performs a client-side scan of the current page. It produces prioritized recommendations (Critical / Important / Enhancement), each containing:
- What: the change to make
- Where: which elements or regions are affected
- Why: the WCAG rationale

Recommendations are generated by the rule engine and optionally refined or prioritized by the AI prompt in `ai-config.js`.

## Detection Methods (high level)

1. Font size and readability
- Function: `analyzeFontSizes()`
- Approach: Enumerates visible text elements and measures `window.getComputedStyle(element).fontSize` and related metrics. The analyzer builds a distribution of font sizes and flags elements below configurable thresholds as `small text` where readability can suffer.
- Thresholds: The project uses pragmatic thresholds aligned with WCAG guidance (e.g., ~16px for body text baseline), but these may be tuned in the code.

2. Contrast detection (color contrast)
- Functions: `getTextContrastSamples()` (top-level), `_effectiveContrast()`, `_parseColor()`, `_relativeLuminance()`, `_contrastRatio()`, `_computeCumulativeOpacity()`, `_blendColors()`
- Approach: For each visible text node, the analyzer:
  - Resolves the computed `color` (foreground) and tries to determine the actual effective background color taking parent elements and overlays into account.
  - Computes relative luminance of foreground/background colors and the WCAG contrast ratio using `_contrastRatio()`.
  - Handles parent opacity and semi-transparency by computing cumulative opacity (`_computeCumulativeOpacity`) and blending colors where needed (`_blendColors`) to approximate the effective rendered color.
  - Flags `low contrast` when the computed ratio falls below WCAG 2.1 AA thresholds (4.5:1 for normal text, 3:1 for large text).
- Limitations: Background images, gradients, complex overlays, or CSS blend modes may not be perfectly resolved by the color math. For pixel-perfect detection in such cases, sampling pixels via a canvas is required (not implemented by default).

3. Headings, structure, and interactive elements
- The analyzer inspects DOM structure to identify headings, landmarks, images without `alt`, and interactive elements without accessible names.
- These checks are rule-based and implemented in `analyzePageContent()` and related helpers.

## Where logic lives (important functions)
- `script.js`
  - `analyzeAccessibility()` – orchestrates the page scan and builds the payload fed to the AI/prioritizer.
  - `analyzeFontSizes()` – returns font-size distribution and `smallTextSamples`.
  - `getTextContrastSamples()` – collects text nodes and computes `contrastRatio` and `hasLowContrast` using `_effectiveContrast`.
  - `_effectiveContrast()` and helper color functions – core color math used to determine WCAG ratios.
  - `parseWCAGRecommendations()` – parses the AI or rule-based recommendations into structured items.
  - `showRecommendations()` – renders the recommendations with WHAT / WHERE / WHY.
  - `applyRec(rec)` / `applyRecommendation(index, action)` / `applyAllActionable()` – functions that apply fixes (see next section).

## How CSS is modified by the analyzer (auto-fixes)

The analyzer applies fixes carefully and aims to keep them reversible / scoped:

- Test-lab classes: A consistent set of CSS classes in `styles.css` are used to inject test violations during testing (e.g., `body.test-small-font`, `body.test-low-contrast`, `body.test-tight-spacing`, `body.test-tiny-buttons`). Auto-fixes remove those classes when applicable.

- Fix strategies:
  1. CSS variables / root overrides
     - Where possible, the analyzer sets or updates CSS variables (on `:root` or `document.documentElement.style`) to change theme-level tokens (colors, base font size) so fixes apply site-wide in a controlled manner.
  2. Inline styles for targeted adjustments
     - For individual elements the analyzer may apply inline styles (e.g., `element.style.fontSize = '18px'`) for precise correction when changing a variable isn't appropriate.
  3. Class removal / toggling
     - The analyzer removes testing classes added by `accessibility-test.html` so the page returns to its corrected state.

- Functions that modify CSS:
  - `adjustFontSize(elements)` – increases font sizes for flagged elements or adjusts base font-size variable.
  - `adjustContrast(samples)` – updates CSS variables for foreground/background or uses inline `color`/`backgroundColor` updates for specific elements.
  - `adjustSpacing()` / `adjustLineHeight()` – tweak spacing/line-height via inline styles or variable updates when flagged.

- Applied improvements tracking
  - `appliedImprovements` (in `script.js`) keeps track of which automated fixes have been applied. The UI avoids suggesting the same actionable improvement twice.

## Workflow for users (quick guide)
1. Open `index.html` in a browser (or run a simple server):

```bash
python3 -m http.server 8080
# Visit http://localhost:8080
```

2. Click **Analyze Page** in the UI.
3. Review the recommendations in the right-hand panel (or chatbot area): each item includes WHAT / WHERE / WHY.
4. For actionable items, click **Apply This Change** or **Apply All Actionable Changes**.
5. Re-run **Analyze Page** to confirm fixes. Manual tasks (e.g., writing alt text, architectural changes) will be shown in a final summary.

## Tips for the target audience
- Developers: treat automated fixes as suggestions—review changes before committing. Use CSS variable updates for theme-level fixes.
- Designers: review color/contrast suggestions in the context of brand guidelines. The analyzer may recommend color shifts to meet WCAG but keep accessibility and branding aligned.
- Accessibility reviewers: use `accessibility-test.html` to inject known violations and validate that auto-fixes behave as expected.

## Known limitations & future improvements
- Complex backgrounds, CSS blend modes, and image-based text can reduce the accuracy of effective contrast estimates. For high-stakes pages, add a pixel-sampling step using `canvas`.
- The analyzer approximates parent overlays and opacity; extremely deep stacking contexts or custom blending will need additional heuristics.
- AI suggestions are prioritized but should be reviewed — parsed recommendations rely on predictable formatting.

## Files to inspect when debugging
- `script.js` — core detection, parsing, and apply logic
 - `script.js` — core detection, parsing, and apply logic (now integrates `axe-core` for automated WCAG checks)
- `styles.css` — test-violation classes and CSS variables used by fixes
- `accessibility-test.html` — test lab for injecting violations and persisting settings
- `ai-config.js` — AI prompt templates and prioritization rules

---

If you want, I can also add an abbreviated link from the main UI that opens this documentation in a new tab. Tell me if you want that linked into the analyzer panel or a footer link.
